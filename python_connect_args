import http.client
import json
import ssl
import argparse

def fetch_data(debug=False):
    # Server details
    host = "example.com"  # Replace with your actual host
    url = "/api/data"  # Replace with the correct endpoint
    port = 443  # HTTPS port

    # Pagination parameters
    limit = 3000
    skip = 0
    all_records = []
    total_records_fetched = 0

    # File to store raw responses
    raw_data_file = "raw_data.txt"

    # Custom SSL context to handle certificate verification and client authentication
    context = ssl.create_default_context(cafile="/path/to/ca-bundle.crt")  # Path to CA bundle
    
    # If client authentication is required, provide the client certificate and key
    context.load_cert_chain(certfile="/path/to/client-cert.pem", keyfile="/path/to/client-key.pem")

    while True:
        # The payload containing the POST data (filters like limit, skip, sort, etc.)
        payload = {
            "limit": limit,
            "skip": skip,
            "sort": {"id": 1}  # Sorting by ID in ascending order
        }
        
        json_payload = json.dumps(payload)

        if debug:
            print(f"Payload: {json_payload}")
        
        try:
            # Create an HTTPS connection to the server
            conn = http.client.HTTPSConnection(host, port, context=context)

            # Set headers for the request
            headers = {
                "Content-Type": "application/json"  # Ensure the Content-Type is JSON
            }

            # Send the POST request with the JSON payload
            conn.request("POST", url, body=json_payload, headers=headers)

            # Get the response from the server
            response = conn.getresponse()

            # Read the raw response
            raw_data = response.read()  # Read as bytes

            # Decode raw data to string
            raw_data_str = raw_data.decode('utf-8')

            # Write raw data to file
            with open(raw_data_file, "a") as file:
                file.write(raw_data_str + "\n")  # Append raw data to the file

            # Check the status code
            if debug:
                print(f"Response Status: {response.status}")
                print(f"Raw Data: {raw_data_str}")

            if response.status == 200:
                try:
                    # Try to parse the JSON data
                    json_data = json.loads(raw_data_str)
                    
                    # Handle response based on its structure
                    if isinstance(json_data, list):
                        # If the response is a list of records
                        num_records = len(json_data)
                        all_records.extend(json_data)
                        total_records_fetched += num_records

                        # If the number of fetched records is less than the limit, stop fetching
                        if num_records < limit:
                            break

                    elif isinstance(json_data, dict):
                        # Handle case where response is a dictionary (e.g., contains metadata)
                        records = json_data.get('records', [])
                        num_records = len(records)
                        all_records.extend(records)
                        total_records_fetched += num_records

                        # Check if more records are available (e.g., based on 'has_more' or 'total' count)
                        has_more = json_data.get('has_more', False)
                        if not has_more:
                            break

                    else:
                        print(f"Unexpected response format: {type(json_data)}")
                        break

                    # Increment the skip parameter for the next batch
                    skip += limit

                except json.JSONDecodeError as json_error:
                    print(f"Error decoding JSON: {json_error}")
                    break

            else:
                print(f"Request failed with status code {response.status}: {raw_data_str}")
                break

        except ssl.SSLError as ssl_error:
            print(f"SSL error occurred: {ssl_error}")
            break
        except Exception as e:
            print(f"An error occurred: {e}")
            break
        finally:
            # Always close the connection
            conn.close()

    # Print or process all fetched records
    print(f"Total records fetched: {total_records_fetched}")
    if debug:
        print("Final Data:", json.dumps(all_records, indent=4))

# Main function to handle argument parsing
if __name__ == "__main__":
    # Argument parser setup
    parser = argparse.ArgumentParser(description="Fetch data with pagination and debugging options.")
    parser.add_argument("--debug", action="store_true", help="Enable debug mode with verbose output")

    # Parse arguments
    args = parser.parse_args()

    # Call the function with the parsed debug argument
    fetch_data(debug=args.debug)

import http.client
import json
import ssl
import argparse
from urllib.parse import urlparse, urljoin

def fetch_data(data_path, debug=False):
    # Define the base URL (root URL)
    base_url = "https://example.com/api/"
    
    # Concatenate base URL with the data path (endpoint)
    full_url = urljoin(base_url, data_path)

    # Parse the full URL into components (scheme, host, path, etc.)
    parsed_url = urlparse(full_url)
    host = parsed_url.hostname
    port = parsed_url.port or 443  # Default to 443 for HTTPS
    path = parsed_url.path

    if debug:
        print(f"Full URL: {full_url}")
        print(f"Connecting to {host} on port {port}, path: {path}")

    # Pagination parameters
    limit = 3000
    skip = 0
    all_records = []
    total_records_fetched = 0

    # File to store raw responses
    raw_data_file = "raw_data.txt"

    # Custom SSL context to handle certificate verification and client authentication
    context = ssl.create_default_context(cafile="/path/to/ca-bundle.crt")  # Path to CA bundle
    
    # If client authentication is required, provide the client certificate and key
    context.load_cert_chain(certfile="/path/to/client-cert.pem", keyfile="/path/to/client-key.pem")

    while True:
        # The payload containing the POST data (filters like limit, skip, sort, etc.)
        payload = {
            "limit": limit,
            "skip": skip,
            "sort": {"id": 1}  # Sorting by ID in ascending order
        }
        
        json_payload = json.dumps(payload)

        if debug:
            print(f"Payload: {json_payload}")
        
        try:
            # Create an HTTPS connection to the server
            conn = http.client.HTTPSConnection(host, port, context=context)

            # Set headers for the request
            headers = {
                "Content-Type": "application/json"  # Ensure the Content-Type is JSON
            }

            # Send the POST request with the JSON payload
            conn.request("POST", path, body=json_payload, headers=headers)

            # Get the response from the server
            response = conn.getresponse()

            # Read the raw response
            raw_data = response.read()  # Read as bytes

            # Decode raw data to string
            raw_data_str = raw_data.decode('utf-8')

            # Write raw data to file
            with open(raw_data_file, "a") as file:
                file.write(raw_data_str + "\n")  # Append raw data to the file

            # Check the status code
            if debug:
                print(f"Response Status: {response.status}")
                print(f"Raw Data: {raw_data_str}")

            if response.status == 200:
                try:
                    # Try to parse the JSON data
                    json_data = json.loads(raw_data_str)
                    
                    # Handle response based on its structure
                    if isinstance(json_data, list):
                        # If the response is a list of records
                        num_records = len(json_data)
                        all_records.extend(json_data)
                        total_records_fetched += num_records

                        # If the number of fetched records is less than the limit, stop fetching
                        if num_records < limit:
                            break

                    elif isinstance(json_data, dict):
                        # Handle case where response is a dictionary (e.g., contains metadata)
                        records = json_data.get('records', [])
                        num_records = len(records)
                        all_records.extend(records)
                        total_records_fetched += num_records

                        # Check if more records are available (e.g., based on 'has_more' or 'total' count)
                        has_more = json_data.get('has_more', False)
                        if not has_more:
                            break

                    else:
                        print(f"Unexpected response format: {type(json_data)}")
                        break

                    # Increment the skip parameter for the next batch
                    skip += limit

                except json.JSONDecodeError as json_error:
                    print(f"Error decoding JSON: {json_error}")
                    break

            else:
                print(f"Request failed with status code {response.status}: {raw_data_str}")
                break

        except ssl.SSLError as ssl_error:
            print(f"SSL error occurred: {ssl_error}")
            break
        except Exception as e:
            print(f"An error occurred: {e}")
            break
        finally:
            # Always close the connection
            conn.close()

    # Print or process all fetched records
    print(f"Total records fetched: {total_records_fetched}")
    if debug:
        print("Final Data:", json.dumps(all_records, indent=4))

# Main function to handle argument parsing
if __name__ == "__main__":
    # Argument parser setup
    parser = argparse.ArgumentParser(description="Fetch data from the API using a data path and debugging options.")
    
    # Positional argument for the data path (endpoint)
    parser.add_argument("data", help="The API data path (endpoint) to fetch data from (e.g., 'data' for '/api/data')")
    
    # Optional debug flag
    parser.add_argument("--debug", action="store_true", help="Enable debug mode with verbose output")

    # Parse arguments
    args = parser.parse_args()

    # Call the function with the parsed arguments
    fetch_data(data_path=args.data, debug=args.debug)

python script.py users --debug
