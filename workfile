import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import javax.mail.*;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import java.io.FileOutputStream;
import java.util.Properties;

public class EmailSender {
    public static void main(String[] args) {
        try {
        Properties properties = new Properties();
        try (InputStream inputStream = getClass().getClassLoader().getResourceAsStream("application.properties")) {
            properties.load(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
     }
    }
}
/*
//it_groups=group1,group2,group3

public enum ValueEnum {
    AA(5), AB(10), AC(15), BA(25), BB(30), BC(35);

    private final int value;

    ValueEnum(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    public static ValueEnum fromString(String name) {
        try {
            return ValueEnum.valueOf(name);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid value name: " + name);
        }
    }
}

import java.util.EnumMap;
import java.util.Map;

public class Student {
    private final Map<ValueEnum, Integer> values;

    public Student(Map<ValueEnum, Integer> values) {
        this.values = values;
    }

    public int getValue(ValueEnum key) {
        return values.getOrDefault(key, 0);
    }
}

public class Teacher {
    private final Map<ValueEnum, Integer> values;

    public Teacher(Map<ValueEnum, Integer> values) {
        this.values = values;
    }

    public int getValue(ValueEnum key) {
        return values.getOrDefault(key, 0);
    }
}

public class ValueDifferenceCalculator {

    public static Map<ValueEnum, Integer> calculateDifference(Student student, Teacher teacher) {
        Map<ValueEnum, Integer> differences = new EnumMap<>(ValueEnum.class);

        for (ValueEnum key : ValueEnum.values()) {
            int studentValue = student.getValue(key);
            int teacherValue = teacher.getValue(key);
            int difference = studentValue - teacherValue;
            differences.put(key, difference);
        }

        return differences;
    }
}

public static boolean matchesParameter(Properties properties, String parameter) {
        // Get the it_groups property
        String itGroupsString = properties.getProperty("it_groups");

        // Split the it_groups string into an array
        String[] itGroupsArray = itGroupsString.split(",");

        // Convert the array to a list
        List<String> itGroupsList = Arrays.asList(itGroupsArray);

        // Check if the parameter matches one of the array members
        return itGroupsList.contains(parameter);
    }
if (ArrayMatcher.matchesParameter(properties, parameter)) {
            System.out.println("Parameter matches one of the array members");
        } else {
            System.out.println("Parameter does not match any of the array members");
        }

public static String[] getGroups() {
        // Load properties from application.properties file
        Properties properties = loadProperties("application.properties");

        // Get the it_groups property
        String itGroupsString = properties.getProperty("it_groups");

        // Split the it_groups string into an array
        return itGroupsString.split(",");
    }

    private static Properties loadProperties(String fileName) {
        Properties properties = new Properties();
        try (InputStream inputStream = GroupChecker.class.getClassLoader().getResourceAsStream(fileName)) {
            properties.load(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return properties;
    }
// Get the it_groups property
        String itGroupsString = properties.getProperty("it_groups");
        
        // Split the it_groups string into an array
        String[] itGroupsArray = itGroupsString.split(",");
        
        // Convert the array to a list
        List<String> itGroupsList = Arrays.asList(itGroupsArray);
        
        // Check if the parameter matches one of the array members
        String parameter = "group2"; // Change this to your parameter
        if (itGroupsList.contains(parameter)) {
            System.out.println("Parameter matches one of the array members");
        } else {
            System.out.println("Parameter does not match any of the array members");
        }
    }
public static void main(String[] args) {
        Properties properties = loadProperties("application.properties");
        // Use properties here
        String propertyValue = properties.getProperty("property.key");
        System.out.println(propertyValue);
    }

    private static Properties loadProperties(String fileName) {
        Properties properties = new Properties();
        try {
            InputStream inputStream = MatchingMaker.class.getClassLoader().getResourceAsStream(fileName);
            if (inputStream == null) {
                System.err.println("Unable to find " + fileName);
                return properties;
            }
            properties.load(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return properties;
    }

            // Read email addresses from Excel
            Workbook workbook = new XSSFWorkbook(new FileInputStream("emails.xlsx"));
            Sheet sheet = workbook.getSheetAt(0); // Assuming data is in the first sheet

            for (Row row : sheet) {
                Cell studentEmailCell = row.getCell(0); // Assuming student email is in the first column
                Cell professorEmailCell = row.getCell(1); // Assuming professor email is in the second column
                
                String studentEmail = studentEmailCell.getStringCellValue();
                String professorEmail = professorEmailCell.getStringCellValue();
                
                // Generate PDF file
                String pdfFilePath = generatePDF();

                // Compose email body
                String emailBody = composeEmailBody();

                // Send email with attached PDF
                sendEmail(studentEmail, professorEmail, emailBody, pdfFilePath);
            }

            workbook.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static String generatePDF() {
        // Use iText or any other library to generate PDF
        // Return the file path of the generated PDF
        return "example.pdf";
    }

    private static String composeEmailBody() {
        // Compose email body using a template
        return "Dear [Recipient],\n\nPlease find attached the document.\n\nBest regards,\n[Your Name]";
    }

    private static void sendEmail(String studentEmail, String professorEmail, String emailBody, String pdfFilePath) {
        // Email configuration
        String host = "smtp.example.com"; // Your SMTP host
        String username = "yourusername"; // Your SMTP username
        String password = "yourpassword"; // Your SMTP password
        String from = "you@example.com"; // Sender email address

        Properties props = new Properties();
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.starttls.enable", "true");
        props.put("mail.smtp.host", host);
        props.put("mail.smtp.port", "587");

        // Authenticate the session
        Session session = Session.getInstance(props, new Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication(username, password);
            }
        });

        try {
            // Create a new message
            Message message = new MimeMessage(session);
            message.setFrom(new InternetAddress(from));
            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(studentEmail)); // Set recipient to student
            message.setSubject("Your Subject Here");

            // Create the email body part
            BodyPart messageBodyPart = new MimeBodyPart();
            messageBodyPart.setText(emailBody);

            // Create the attachment
            MimeBodyPart attachmentBodyPart = new MimeBodyPart();
            attachmentBodyPart.attachFile(pdfFilePath);

            // Create multipart email
            Multipart multipart = new MimeMultipart();
            multipart.addBodyPart(messageBodyPart);
            multipart.addBodyPart(attachmentBodyPart);

            // Set the email content
            message.setContent(multipart);

            // Send the message
            Transport.send(message);

            System.out.println("Email sent to " + studentEmail);
        } catch (Exception e) {
            e.printStackTrace();
        }



    }
}

1. Create config.properties file:
properties
Code kopieren
app.name=Student-Teacher Matching App
organization.keys=Biology1,Chemistry1,Physics1
organization.Biology1=BG
organization.Chemistry1=CH
organization.Physics1=PH
# Add more properties as needed
2. Create ConfigProperties class:
java
Code kopieren
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

public class ConfigProperties {
    private static final Properties properties = new Properties();

    static {
        // Load properties from the file
        try (InputStream input = ConfigProperties.class.getClassLoader().getResourceAsStream("config.properties")) {
            if (input == null) {
                System.out.println("Sorry, unable to find config.properties");
                return;
            }

            properties.load(input);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    public static String getProperty(String key) {
        return properties.getProperty(key);
    }
}
3. Create OrganizationMapping class:
java
Code kopieren
import java.util.HashMap;
import java.util.Map;

public class OrganizationMapping {
    private static final Map<String, String> organizationMappings = new HashMap<>();

    static {
        // Populate the map with properties
        for (String key : ConfigProperties.getProperty("organization.keys").split(",")) {
            String value = ConfigProperties.getProperty("organization." + key);
            if (value != null) {
                organizationMappings.put(key, value);
            }
        }
    }

    public static String getMappedOrganization(String studentOrg) {
        return organizationMappings.get(studentOrg);
    }
}
4. Update GenerateScore class:
java
Code kopieren
import java.util.ArrayList;

public class GenerateScore {

    // Method to check the match
    public static int matchOrganization(Student student, Teacher teacher) {
        String studentOrg = student.getOrganization();
        String teacherOrg = teacher.getTeacherOrganization();

        // If the student's organization is null or empty, ignore the match
        if (studentOrg == null || studentOrg.isEmpty()) {
            return -1;  // Or another value indicating ignored match
        }

        String mappedTeacherOrg = OrganizationMapping.getMappedOrganization(studentOrg);

        // Check if the mapping exists and matches the teacher's organization
        return mappedTeacherOrg != null && mappedTeacherOrg.equals(teacherOrg) ? 1 : 0;
    }

    // Method to generate scores for a list of students and a teacher
    public static void generateScores(ArrayList<Student> students, Teacher teacher) {
        for (Student student : students) {
            int result = matchOrganization(student, teacher);
            // Handle the result as needed
            System.out.println("Match result for student: " + result);
        }
    }
}
5. Update Main class:
java
Code kopieren
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        // Example usage of properties
        String appName = ConfigProperties.getProperty("app.name");
        System.out.println("Application Name: " + appName);

        ArrayList<Student> studentList = new ArrayList<>();
        studentList.add(new Student("Biology1"));
        studentList.add(new Student(null));  // Or new Student("") for empty organization

        Teacher teacher = new Teacher("BG");

        GenerateScore.generateScores(studentList, teacher);
    }
}

// Sample Student class
class Student {
    private String organization;

    public Student(String organization) {
        this.organization = organization;
    }

    public String getOrganization() {
        return organization;
    }
}

// Sample Teacher class
class Teacher {
    private String organization;

    public Teacher(String organization) {
        this.organization = organization;
    }

    public String getTeacherOrganization() {
        return organization;
    }
}

private int matchCheck(String studentValue, String teacherValue, boolean shouldMatch) {
        boolean isEqual = studentValue.equalsIgnoreCase(teacherValue);
        return shouldMatch ? (isEqual ? 1 : 0) : (isEqual ? 0 : 1);
    }

    // Method for shouldMatchCheck
    private int shouldMatchCheck(String studentValue, String teacherValue) {
        return matchCheck(studentValue, teacherValue, true);
    }

    // Method for shouldNotMatchCheck
    private int shouldNotMatchCheck(String studentValue, String teacherValue) {
        return matchCheck(studentValue, teacherValue, false);
    }
/*

/*
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

public class MatchingMakerCGPT {

  private static final String LOCAL_PATH = "MentoringInput";
  private static final String THIS_YEAR = "2024";

  public static void main(String[] args) {
    String path = args.length > 0 ? args[0] : LOCAL_PATH;
    String year = args.length > 1 ? args[1] : THIS_YEAR;
    path = "/";

    Properties appProperties = loadProperties("application.properties");
    String propertyValue = appProperties.getProperty("orgArea.keys");
    System.out.println("propertyValue " + propertyValue);

    ArrayList<OrgUnit> orgUnitMentees = loadOrgUnitData(path + "OrgMentees.xLsx");
    ArrayList<OrgUnit> orgUnitMentors = loadOrgUnitData(path + "OrgMentors.xLsx");

    ArrayList<Mentee> menteeAll = loadMenteesData(path + "2024 MenteesSurvey.xLsx");
    System.out.println("menteeALL load size: " + menteeAll.size());

    ArrayList<Mentee> menteeSubmitted = getSubmittedMentees(menteeAll);
    System.out.println("menteeSubmitted size: " + menteeSubmitted.size());

    ArrayList<Mentee> menteeUnSubmitted = getUnSubmittedMentees(menteeAll);
    System.out.println("menteeUnSubmitted size: " + menteeUnSubmitted.size());

    ArrayList<Mentee> menteeWithOrgInfo = extendWithOrgUnit(menteeSubmitted, orgUnitMentees);
    System.out.println("menteeAddOrgInfo size: " + menteeWithOrgInfo.size());

    ArrayList<Mentee> menteeInCountry = excludeCountryMentees(menteeWithOrgInfo);
    ArrayList<Mentee> menteeQualified = excludeOtherMentees(menteeInCountry);
    System.out.println("menteeExt after exclusion of country and other size: " + menteeQualified.size());

    ArrayList<Mentor> mentorAll = loadMentorsData(path + "2024 MentorsSurvey.xls");
    System.out.println("mentorALL load size: " + mentorAll.size());

    ArrayList<Mentor> mentorSubmitted = getSubmittedMentors(mentorAll);
    System.out.println("mentorSubmitted size: " + mentorSubmitted.size());

    ArrayList<Mentor> mentorUnSubmitted = getUnSubmittedMentors(mentorAll);
    System.out.println("mentorUnSubmitted size: " + mentorUnSubmitted.size());

    ArrayList<Mentor> mentorWithOrgInfo = extendWithOrgUnit(mentorSubmitted, orgUnitMentors);
    ArrayList<Mentor> mentorInCountry = excludeCountryMentors(mentorWithOrgInfo);
    ArrayList<Mentor> mentorQualified = mentorInCountry;

    HashMap<Mentee, MentorScore> bestMatches = BestScoresProcessor.generateBestMatchingScores(menteeQualified, mentorQualified);
    System.out.println("bestMatches key size: " + bestMatches.size());

    ArrayList<String> matches = new ArrayList<>();
    ArrayList<Mentor> bestMentors = new ArrayList<>();
    ArrayList<Mentee> bestMentees = new ArrayList<>();
    for (Map.Entry<Mentee, MentorScore> entry : bestMatches.entrySet()) {
      StringBuilder sb = new StringBuilder();
      sb.append(entry.getKey().toStringShort()).append(";");
      sb.append(entry.getValue().getMentor().toStringShort()).append(";").append(entry.getValue().getScore()).append(";");
      matches.add(sb.toString());
      bestMentees.add(entry.getKey());
      bestMentors.add(entry.getValue().getMentor());
      menteeQualified.remove(entry.getKey());
    }
    System.out.println("MATCHED STUDENTS: " + bestMentees.size());
    System.out.println("MATCHED TEACHERS: " + bestMentors.size());

    String[] matchingHeaders = {"ID Mentee", "First Name Mentee", "Last Name Mentee", "Email Mentee", "Level Mentee",

        "City Name Mentee", "Street Name Mentee", "Language English", "OrgArea", "Score"};
    ExportMatchingResults matchToExcel = new ExportMatchingResults(path + "MentorMatching_" + year + ".xlsx", matchingHeaders);
    matchToExcel.matchingFileAll(matches, "MentorMatching_" + year, matchingHeaders);

    ResultsLists<Mentee> resultListMentee = new ResultsLists<>();
    resultListMentee.setMentTypeUppercase("MENTEES");
    resultListMentee.setBestMentoringTypes(bestMentees);
    resultListMentee.setMentoringTypeALL(menteeAll);
    resultListMentee.setMentoringTypeQualified(menteeQualified);
    resultListMentee.setMentoringTypeUnSubmitted(menteeUnSubmitted);
    WriteMentoringResults<Mentee> wnMentee = new WriteMentoringResults<>(matchToExcel, year);
    wnMentee.writeResultsMentoringType(matchToExcel, resultListMentee);

    ResultsLists<Mentor> resultListMentor = new ResultsLists<>();
    resultListMentor.setMentoringTypeUpperCase("MENTORS");
    resultListMentor.setBestMentoringTypes(bestMentors);
    resultListMentor.setMentoringTypeALL(mentorAll);
    resultListMentor.setMentoringTypeQualified(mentorQualified);
    resultListMentor.setMentoringTypeUnSubmitted(mentorUnSubmitted);
    WriteMentoringResults<Mentor> wnMentor = new WriteMentoringResults<>(matchToExcel, year);
    wnMentor.writeResultsMentoringType(matchToExcel, resultListMentor);
  }

  private static Properties loadProperties(String fileName) {
    Properties appProperties = new Properties();
    try (InputStream inputStream = MatchingMakerCGPT.class.getClassLoader().getResourceAsStream(fileName)) {
      if (inputStream == null) {
        System.err.println("Unable to find " + fileName);
        return appProperties;
      }
      appProperties.load(inputStream);
    } catch (IOException e) {
      e.printStackTrace();
    }
    return appProperties;
  }

  private static ArrayList<OrgUnit> loadOrgUnitData(String filePath) {
    LoadOrgUnitData loader = new LoadOrgUnitData(filePath);
    return loader.getOrgUnit();
  }

  private static ArrayList<Mentee> loadMenteesData(String filePath) {
    LoadMenteesData loader = new LoadMenteesData(filePath);
    return loader.getMentees();
  }

  private static ArrayList<Mentor> loadMentorsData(String filePath) {
    LoadMentorsData loader = new LoadMentorsData(filePath);
    return loader.getMentors();
  }

  private static ArrayList<Mentee> getSubmittedMentees(ArrayList<Mentee> mentees) {
    ExclusionProcessor exclusionProcessor = new ExclusionProcessor();
    return exclusionProcessor.excLusionNotSubmitted(mentees).get(0);
  }

  private static ArrayList<Mentee> getUnSubmittedMentees(ArrayList<Mentee> mentees) {
    ExclusionProcessor exclusionProcessor = new ExclusionProcessor();
    return exclusionProcessor.excLusionNotSubmitted(mentees).get(1);
  }

  private static ArrayList<Mentor> getSubmittedMentors(ArrayList<Mentor> mentors) {
    ExclusionProcessor exclusionProcessor = new ExclusionProcessor();
    return exclusionProcessor.exclusionNotSubmitted(mentors).get(0);
  }

  private static ArrayList<Mentor> getUnSubmittedMentors(ArrayList<Mentor> mentors) {
    ExclusionProcessor exclusionProcessor = new ExclusionProcessor();
    return exclusionProcessor.exclusionNotSubmitted(mentors).get(1);
  }

  private static ArrayList<Mentee> extendWithOrgUnit(ArrayList<Mentee> mentees, ArrayList<OrgUnit> orgUnits) {
    ExtendMentoringInfo teachingInfo = new ExtendMentoringInfo();
    return teachingInfo.extendWithOrgUnit(mentees, orgUnits);
  }

  private static ArrayList<Mentor> extendWithOrgUnit(ArrayList<Mentor> mentors, ArrayList<OrgUnit> orgUnits) {
    ExtendMentoringInfo teachingInfo = new ExtendMentoringInfo();
    return teachingInfo.extendWithOrgUnit(mentors, orgUnits);
  }

  private static ArrayList<Mentee> excludeCountryMentees(ArrayList<Mentee> mentees) {
    ExclusionProcessor exclusionProcessor = new ExclusionProcessor();
    return exclusionProcessor.exclusionCountry(mentees);
  }

  private static ArrayList<Mentee> excludeOtherMentees(ArrayList<Mentee> mentees) {
    ExclusionProcessor exclusionProcessor = new ExclusionProcessor();
    return exclusionProcessor.exclusionOther(mentees);
  }

  private static ArrayList<Mentor> excludeCountryMentors(ArrayList<Mentor> mentors) {
    ExclusionProcessor exclusionProcessor = new ExclusionProcessor();
    return exclusionProcessor.exclusionCountry(mentors);
  }

  private static ArrayList<Mentor> excludeOtherMentors(ArrayList<Mentor> mentors) {
    ExclusionProcessor exclusionProcessor = new ExclusionProcessor();
    return exclusionProcessor.exclusionOther(mentors);
  }
}
*/
