/*


objects.sort(Comparator.comparing(MyObject::getFirstParam)
                .thenComparing(Comparator.comparing(MyObject::getSecondParam).reversed()));

objects.sort(Comparator.comparing(MyObject::getFirstParam)
                .thenComparing(Comparator.comparing(MyObject::getSecondParam).reversed()));

objects.sort(Comparator.comparing(MyObject::getFirstParam)
                .thenComparing(MyObject::getSecondParam)
                .reversed());

objects.sort(Comparator.comparing(MyObject::getFirstParam, Comparator.nullsLast(String::compareTo))
                .thenComparing(MyObject::getSecondParam));

public class Semaphore {
  private int count;

  public Semaphore(int initCount) {
    this.count = initCount;
  }

  public synchronized int getCount() {
    return count;
  }

  public synchronized boolean trySemDown() {
    if (count > 0) {
      semDown();
      return true;
    }
    return false;
  }

  public synchronized void semDown() {
    while (count-- <= 0) {
      try {
        wait();
      } catch (InterruptedException e) {
        // Restore the interrupted status
        Thread.currentThread().interrupt();
        // Log the interruption and break the loop
        System.err.println("Thread interrupted; semaphore integrity compromised.");
        break;
      }
    }
  }

  public synchronized void semUp() {
    if (++count > 0) {
      notifyAll(); // Use notifyAll() to wake up all waiting threads
    }
  }
}

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.*;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;

public class ResultsProcessor {

    private static final String FILE_NAME = "Results.xlsx";
    private static final String RENAMED_FILE_NAME = "Results.v1.xlsx";
    private static final String NEW_FILE_NAME = "Results_new.xlsx";
    private static final String NO_VALUE = "NO";
    private static final String YES_VALUE = "YES";

      LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd_HHmm");
        String formattedDateTime = now.format(formatter);
        String newFileName = "Results_" + formattedDateTime + ".xlsx";

        try {
            // Rename the file
            Files.move(Paths.get(ORIGINAL_FILE_NAME), Paths.get(newFileName), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("File renamed to: " + newFileName);
        } catch (IOException e) {
            e.printStackTrace();
        }

    public static void main(String[] args) {
        File file = new File(FILE_NAME);

        if (!file.exists()) {
            System.out.println("File does not exist.");
            return;
        }

        try (FileInputStream fis = new FileInputStream(file);
             Workbook workbook = new XSSFWorkbook(fis)) {

            Sheet sheet = workbook.getSheetAt(0);
            boolean foundNo = false;
            List<String> noRowsFirstColumnValues = new ArrayList<>();
            List<Row> yesRows = new ArrayList<>();
            List<Row> noRows = new ArrayList<>();

            // Iterate over the rows to find "NO" and "YES"
            for (Row row : sheet) {
                Cell cell = row.getCell(2); // 3rd column is index 2
                if (cell != null && cell.getStringCellValue().equals(NO_VALUE)) {
                    foundNo = true;
                    noRows.add(row);
                    noRowsFirstColumnValues.add(row.getCell(0).getStringCellValue());
                } else if (cell != null && cell.getStringCellValue().equals(YES_VALUE)) {
                    yesRows.add(row);
                }
            }

            if (foundNo) {
                // Rename the existing file
                Files.move(Paths.get(FILE_NAME), Paths.get(RENAMED_FILE_NAME), StandardCopyOption.REPLACE_EXISTING);

                // Create a new Results file with only "YES" rows
                try (Workbook newWorkbook = new XSSFWorkbook()) {
                    Sheet newSheet = newWorkbook.createSheet("Results");

                    // Copy "YES" rows
                    int rowIndex = 0;
                    for (Row yesRow : yesRows) {
                        Row newRow = newSheet.createRow(rowIndex++);
                        copyRow(yesRow, newRow);
                    }

                    // Append "NO" rows to the new Results file
                    for (Row noRow : noRows) {
                        Row newRow = newSheet.createRow(rowIndex++);
                        copyRow(noRow, newRow);
                    }

                    // Write to the new file
                    try (FileOutputStream fos = new FileOutputStream(NEW_FILE_NAME)) {
                        newWorkbook.write(fos);
                    }
                }

                // Continue with other tasks using the data from "NO" rows
                System.out.println("Processing complete. First column values of 'NO' rows:");
                for (String value : noRowsFirstColumnValues) {
                    System.out.println(value);
                }

            } else {
                System.out.println("No rows with 'NO' found. No new file created.");
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void copyRow(Row sourceRow, Row targetRow) {
        for (int i = 0; i < sourceRow.getLastCellNum(); i++) {
            Cell oldCell = sourceRow.getCell(i);
            Cell newCell = targetRow.createCell(i);

            if (oldCell == null) {
                newCell.setCellValue("");
                continue;
            }

            switch (oldCell.getCellType()) {
                case STRING:
                    newCell.setCellValue(oldCell.getStringCellValue());
                    break;
                case NUMERIC:
                    newCell.setCellValue(oldCell.getNumericCellValue());
                    break;
                case BOOLEAN:
                    newCell.setCellValue(oldCell.getBooleanCellValue());
                    break;
                case FORMULA:
                    newCell.setCellFormula(oldCell.getCellFormula());
                    break;
                default:
                    newCell.setCellValue("");
            }
        }
    }
}

---

*/public interface ProcessLauncher {
    void command(String... strs);
    Process start() throws IOException;
}

private static final int EXIT_SUCCESS = 0;
private final Supplier<ProcessLauncher> processLauncherSupplier = this::createProcessLauncher;

public boolean runProcess(String shellCommand, String processDisplayName) {
    ProcessLauncher processLauncher = processLauncherSupplier.get();
    processLauncher.command("bash", "-c", shellCommand);
    Process process = null;
    try {
        process = processLauncher.start();
        int exitVal = process.waitFor(); // This line should throw InterruptedException
        return EXIT_SUCCESS == exitVal;
    } catch (InterruptedException e) {
        // Restore the interrupted status
        Thread.currentThread().interrupt();
        log.error("Process was interrupted: " + e.getMessage(), e);
        return false;
    } catch (IOException e) {
        log.error("I/O error occurred while running the process: " + e.getMessage(), e);
        return false;
    } finally {
        if (process != null) {
            try {
                process.destroy();
            } catch (Throwable t) {
                log.error("Cannot destroy process: " + t.getMessage(), t);
            }
        }
    }
}


////
public boolean runProcess(String shellCommand, String processDisplayName) {
    ProcessLauncher processLauncher = processLauncherSupplier.get();
    processLauncher.command("bash", "-c", shellCommand);
    Process process = null;
    try {
        process = processLauncher.start();
        int exitVal = process.waitFor(); // This line throws InterruptedException
        return EXIT_SUCCESS == exitVal;
    } catch (InterruptedException e) {
        // Restore the interrupted status
        Thread.currentThread().interrupt();
        log.error("Process was interrupted: " + e.getMessage(), e);
        return false;
    } catch (IOException e) {
        log.error("I/O error occurred while running the process: " + e.getMessage(), e);
        return false;
    } catch (Exception e) { // Catch all other exceptions
        log.error("Unexpected error while running the process: " + e.getMessage(), e);
        return false;
    } finally {
        if (process != null) {
            try {
                process.destroy();
            } catch (Exception e) {
                log.error("Cannot destroy process: " + e.getMessage(), e);
            }
        }
    }
}
//
public boolean runProcess(String shellCommand, String processDisplayName) {
    ProcessLauncher processLauncher = processLauncherSupplier.get();
    processLauncher.command("bash", "-c", shellCommand);
    Process process = null;
    try {
        process = processLauncher.start();
        int exitVal = process.waitFor(); // This line throws InterruptedException
        return EXIT_SUCCESS == exitVal;
    } catch (InterruptedException e) {
        // Restore the interrupted status
        Thread.currentThread().interrupt();
        log.error("Process was interrupted: " + e.getMessage(), e);
        return false;
    } catch (IOException e) {
        log.error("I/O error occurred while running the process: " + e.getMessage(), e);
        return false;
    } catch (Throwable t) {
        log.error("Unexpected throwable caught while running the process: " + t.getMessage(), t);
        return false;
    } finally {
        if (process != null) {
            try {
                process.destroy();
            } catch (Throwable t) {
                log.error("Cannot destroy process: " + t.getMessage(), t);
            }
        }
    }
}

@Override
public boolean equals(Object obj) {
    // Check if the current object is compared with itself
    if (this == obj) {
        return true;
    }

    // Check if the other object is an instance of the same class
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }

    // Cast the object to the current class type
    YourClassName other = (YourClassName) obj;

    // Compare the fields for equality
    // Assuming 'f' is not null, use its equals method to compare
    return f.equals(other.f);
}

// The hashCode method is already provided
@Override
public int hashCode() {
    return f.hashCode();
}


@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    YourClassName other = (YourClassName) obj;
    return f != null ? f.equals(other.f) : other.f == null;
}

@Override
public int hashCode() {
    return f != null ? f.hashCode() : 0;
}

Optional<String> result = Optional.ofNullable(objectReference)
                                   .map(obj -> obj.get());  // Assuming 'get()' is safe to call
if (result.isPresent()) {
    // do something
}

//
